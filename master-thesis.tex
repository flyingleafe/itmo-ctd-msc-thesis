\documentclass[specification,annotation,times]{itmo-student-thesis}
%% \documentclass[times]{itmo-student-thesis}

%% Опции пакета:
%% - specification - если есть, генерируется задание, иначе не генерируется
%% - annotation - если есть, генерируется аннотация, иначе не генерируется
%% - times - делает все шрифтом Times New Roman, собирается с помощью xelatex
%% - pscyr - делает все шрифтом Times New Roman, требует пакета pscyr.

%% Делает запятую в формулах более интеллектуальной, например:
%% $1,5x$ будет читаться как полтора икса, а не один запятая пять иксов.
%% Однако если написать $1, 5x$, то все будет как прежде.
\usepackage{icomma}

%% Один из пакетов, позволяющий делать таблицы на всю ширину текста.
\usepackage{tabularx}

%% Мульти-иллюстрации
\usepackage[caption=false,font=footnotesize]{subfig}

%% Данные пакеты необязательны к использованию в бакалаврских/магистерских
%% Они нужны для иллюстративных целей
%% Начало
\usepackage{tikz}
\usetikzlibrary{arrows}
%% Конец

%% Указываем файл с библиографией.
\addbibresource{master-thesis.bib}

%% Указываем путь к иллюстрациям
\graphicspath{{img/}{live_img/}}

%% Шорткаты
\DeclareMathOperator{\argmin}{argmin}
\DeclareMathOperator{\argmax}{argmax}

%% Теоремы/определения
\theoremstyle{definition}

\newtheorem{definition-ru}{Определение}

\begin{document}

\studygroup{M4239}
\title{Децентрализованный алгоритм управления конвейерной системой с использованием методов мультиагентного обучения с подкреплением}
\author{Мухутдинов Дмитрий Вадимович}{Мухутдинов Д.В.}
\supervisor{Фильченков Андрей Александрович}{Фильченков А.А.}{к.ф-м.н.}{кафедра КТ}
\publishyear{2019}
%% Дата выдачи задания. Можно не указывать, тогда надо будет заполнить от руки.
\startdate{01}{сентября}{2017}
%% Срок сдачи студентом работы. Можно не указывать, тогда надо будет заполнить от руки.
\finishdate{31}{мая}{2019}
%% Дата защиты. Можно не указывать, тогда надо будет заполнить от руки.
\defencedate{07}{июня}{2019}

\addconsultant{Вяткин В.В.}{проф., д.т.н.}

\secretary{Павлова О.Н.}

%% Задание
%%% Техническое задание и исходные данные к работе
\technicalspec{Требуется разработать децентрализованный алгоритм управления
  конвейерной системы для транспортировки багажа. Алгоритм должен позволять
  контроллерам конвейерной сети динамически изменять свое поведение в целях
  адаптации под изменившиеся условия работы, такие как поломка одного из
  конвейеров или изменение интенсивности потока багажа. Алгоритм должен
  обеспечивать своевременную доставку багажных единиц до пунктов назначения, в
  то же время минимизируя энергопотребление всей системы в целом.
}

%%% Содержание выпускной квалификационной работы (перечень подлежащих разработке вопросов)
\plannedcontents{Пояснительная записка должна содержать обзор существующих
  результатов в сфере управления конвейерными системами, а также в сферах,
  имеющих непосредственное отношение к предложенному алгоритму (таких как
  сетевая маршрутизация и обучение с подкреплением). Также записка должна
  содержать подробное изложение предложенного алгоритма и данные
  экспериментального сравнения его производительности с производительностью
  существующих методов управления конвейерной системой, проведенного с помощью
  виртуальной имитационной модели конвейерной сети.
}

%%% Исходные материалы и пособия 
\plannedsources{\begin{enumerate}
  \item Richard S. Sutton and Andrew G. Barto. Reinforcement Learning: An Introduction. The MIT Press, 2012
  \item Mnih et al. Human-level control through deep reinforcement learning. Nature, 518(7540):529–533, 2015.
\end{enumerate}}

%%% Цель исследования
\researchaim{
  Разработка децентрализованного алгоритма управления конвейерной системой,
  способного адаптироваться к гетерогенным изменениям в условиях работы.
}

%%% Задачи, решаемые в ВКР
\researchtargets{\begin{enumerate}
    \item разработка виртуальной имитационной модели конвейерной сети,
      позволяющей проводить сравнительный анализ алгоритмов управления;
    \item реализация ряда известных алгоритмов управления конвейерной сетью (а
      также маршрутизации) в рамках разработанной имитационной модели;
    \item разработка алгоритма, соответствующего поставленным требованиям;
    \item экспериментальное сравнение разработанного алгоритма с существующими
      по качеству работы.
\end{enumerate}}

%%% Использование современных пакетов компьютерных программ и технологий
\addadvancedsoftware{Язык программирования Python 3.6}{Гл. \ref{experiments};
  приложения \ref{apx:bad-results}, \ref{apx:simulators}}
\addadvancedsoftware{Библиотека для дискретно-событийного моделирования SimPy}{Гл. \ref{experiments};
  приложения \ref{apx:bad-results}, \ref{apx:simulators}}
\addadvancedsoftware{Библиотека для операций с графами NetworkX}{Гл. \ref{experiments};
  приложения \ref{apx:bad-results}, \ref{apx:simulators}}
\addadvancedsoftware{Математические пакеты NumPy и SciPy}{Гл. \ref{experiments};
  приложения \ref{apx:bad-results}, \ref{apx:simulators}}
\addadvancedsoftware{Библиотеки для машинного обучения scikit-learn и PyTorch}{Гл. \ref{experiments};
  приложения \ref{apx:bad-results}, \ref{apx:simulators}}
\addadvancedsoftware{Среда интерактивной разработки Jupyter Lab}{Гл. \ref{experiments};
  приложения \ref{apx:bad-results}, \ref{apx:simulators}}
\addadvancedsoftware{Библиотеки Matplotlib, Seaborn и Pandas для обработки и визуализации данных}{Гл. \ref{experiments};
  приложения \ref{apx:bad-results}, \ref{apx:simulators}}

%%% Краткая характеристика полученных результатов 
\researchsummary{
  Разработан алгоритм управления конвейерной системой на основе глубокого
  мультиагентного обучения с подкреплением. В ходе экспериментального
  исследования было установлено, что разработанный алгоритм превосходит
  существующие по качеству работы и способен адаптироваться к изменениям во
  внешней среде.
}

%%% Гранты, полученные при выполнении работы 
\researchfunding{
  Государственное задание № 2.8866.2017/БЧ <<Технология разработки программного
  обеспечения систем управления ответственными объектами на основе глубокого
  обучения и конечных автоматов>>
}

%%% Наличие публикаций и выступлений на конференциях по теме выпускной работы
\researchpublications{
\begin{refsection}
\nocite{mukhutdinov2019multi}
\nocite{mukhutdinov2019kmu}
\printannobibliography
\end{refsection}
}

%% Эта команда генерирует титульный лист и аннотацию.
\maketitle{Магистр}

%% Оглавление
\tableofcontents

%% Макрос для введения. Совместим со старым стилевиком.
\startprefacepage

Конвейерные системы широко применяются для автоматизированной транспортировки
объектов и материалов. Они являются неотъемлемой частью комплексов промышленного
оборудования, пунктов сортировки грузов, багажных систем в аэропортах и т. д..
Оптимизация работы таких системы имеет высокую практическую и экономическую
значимость, что мотивирует поиск эффективных методов управления конвейерными
системами.

Для управления большинством современных конвейерных систем применяются
централизованные статические стратегии управления, специально разрабатываемые
под конкретную систему одновременно с проектированием ее физической топологии в
целях решения задач конкретного предприятия \cite{de1994baggage}. Преимуществами
такого подхода являются высокая производительность работы и предсказуемость
поведения системы. Недостатками такого подхода являются высокая стоимость и
долгие сроки разработки кастомизированной стратегии управления, неспособность
системы адаптироваться к изменениям во внешний условиях, не учтенных во время
проектирования (таким как неожиданный отказ отдельных элементов системы), а
также наличие централизованного контроллера как критической точки отказа.

В связи с обозначенными недостатками использования кастомизированных стратегий
управления существует интерес к разработке обобщенных систематических подходов к
управлению конвейерными системами. Наиболее популярным подходом из используемых
является управление с прогнозируемыми моделями (\textit{англ.} model predictive
control, MPC) \cite{qin2003survey}. Управление с прогнозируемыми моделями
изначально разрабатывалось для задач химической промышленности и
нефтепереработки \cite{eaton1992model}, и на данный момент широко используется в
этих сферах. В последние несколько лет повысился интерес к применению данного
подхода к управлению другими типами киберфизических систем, в том числе
промышленными конвейерными линиями \cite{cataldo2016dynamic, luo2015energy} и
системами распределения багажа на основе рельсовых тележек (\textit{англ.}
destination coded vehicles, DCVs) \cite{tarau2010model, zeinaly2015integrated}.
Существующие алгоритмы на основе управления с прогнозируемыми моделями
обобщаются на различные конкретные конфигурации физических систем, но все еще
предусматривают наличие централизованного контроллера. Кроме того, модификация
существующего алгоритма управления (например, добавления учета энергопотребления
системы) во многих случаях является нетривиальной задачей, так как
оптимизируемая функция во фреймворке MPC должна выражаться как задача линейного
(\textit{англ.} linear programming, LP) или квадратичного программирования
(\textit{англ.} quadratic programming, QP). В связи с этим существует интерес к
разработке иных, децентрализованных подходов к управлению конвейерными сетями,
требующих менее строгих ограничений к характеру решаемой задачи.

При рассмотрении штучных конвейеров, перемещающих отдельные объекты, как в
случае систем для перемещения багажа в аэропортах, задачу управления конвейерной
системой можно декомпозировать на несколько подзадач, основными из которых являются задачи
маршрутизации объектов и предотвращения их столкновения.
Первая из этих подзадач по большей части сводится к задаче пакетной маршрутизации
(\textit{англ.} packet routing). Задача пакетной маршрутизации --- это задача
поиска пути наименьшей стоимости в графе из текущей вершины $n$ в вершину
назначения $d$. В контексте конвейерных систем топология конвейерной сети может
быть представлена в виде ориентированного графа, а перемещаемые по конвейерам
объекты могут быть абстрагированы как <<пакеты>>. 

Задача пакетной маршрутизации впервые обрела актуальность с появлением
компьютерных сетей. Первые алгоритмы сетевой маршрутизации появились в процессе
разработки сети ARPANet. Именно тогда были изобретены такие подходы к пакетной
маршрутизации, как дистанционно-векторный (\textit{англ.} distance-vector)
\cite{arpanet-orig} и состояния каналов связи (\textit{англ.} link-state)
\cite{link-state-arpanet}, которые и по сей день лежат в основе
таких стандартных и широко применяемых алгоритмов сетевой маршрутизации, как
Routing Information Protocol (RIP) \cite{rip-rfc} и Open Shortest Path First
(OSPF) \cite{ospf-rfc}. Преимуществами алгоритмов сетевой маршрутизации являются
обусловленные характером задачи децентрализованность, низкая требовательность к
вычислительным ресурсам и устойчивость к отказам маршрутизаторов и обрывам
соединений. В работе \cite{vyatkin-controllers} было продемонстрировано, что
простой дистанционно-векторный алгоритм маршрутизации может быть напрямую
применен к задаче управления конвейерной системой для транспортировки багажа,
что позволяет достигнуть устойчивости системы к отказам отдельных конвейеров.
Однако, в силу своей простоты, дистанционно-векторный алгоритм решает
исключительно задачу направления перемещаемых объектов вдоль кратчайших путей в
конвейерной сети, что ограничивает его применимость в тех случаях, когда
необходимо учитывать дополнительные критерии оптимизации (такие как
энергопотребление системы).

Cуществуют и другие подходы к решению задачи пакетной маршрутизации. Одним из
таких подходов является подход на основе идеи обучения с подкреплением
(\textit{англ.} reinforcement learing, RL). Первым таким алгоритмом стал алгоритм
Q-routing \cite{q-routing-orig}, основанный на методе Q-learning
\cite{q-learning-orig}. Этот алгоритм, как и его модификации
\cite{predictive-q-routing, dual-q-routing}, благодаря обучению с подкреплением
оказался способен лучше адаптироваться к изменениям в интенсивности сетевого
трафика, чем алгоритмы, основанные на вычислении кратчайшего пути. Но из-за
использования большого количества служебных сообщений, использующих те же каналы
передачи данных, что и целевые пакеты, применение таких алгоритмов в реальных
компьютерных сетях ограничено.

В контексте конвейерных сетей, однако, целевые <<пакеты>> являются физическими
объектами (например, чемоданами), перемещаемыми по конвейерной ленте, в то время
как служебные сообщения передаются по проводным соединениям между контроллерами.
Таким образом, время распространения служебных сообщений по системе пренебрежимо
мало по сравнению с временем перемещения целевых объектов, что нивелирует
озвученный недостаток алгоритмов маршрутизации, основанных на обучении с
подкреплением.

В данной работе будет предложено несколько модификаций гибридного децентрализованного
алгоритма управления конвейерной системой, основанного на методе Q-routing, но
использующего нейронную сеть в качестве обучающегося агента. Для демонстрации
способности работы алгоритма в различных постановках задачи маршрутизации он
будет исследован как в имитационной модели конвейерной системы, так и в
имитационной модели абстрактной компьютерной сети.

В главе 1 будет рассмотрена сама задача управления штучной конвейерной системой.
Она будет разбита на подзадачи, такие как задача маршрутизации, задача
избежания столкновений и задача оптимизации энергопотребления. Для каждой из
этих задач будут рассмотрены известные подходы к их решению, включая подходы
из смежных областей, таких как сетевая маршрутизация и управление другими типами
киберфизических систем. Также будет сформулирована обобщенная постановка
задачи маршрутизации в терминах мультиагентного обучения с подкреплением, к
которой будет сведена задача управления конвейерной системой. Будут рассмотрены
существующие алгоритмы маршрутизации, их сильные и слабые стороны. Также будут
рассмотрены существующие методы обучения нейронных сетей с подкреплением, в том
числе в мультиагентном случае.

В главе 2 будет рассмотрен предложенный алгоритм и его модификации и обоснованы
решения, принятые в ходе его разработки.

В главе 3 будут приведены экспериментальные результаты работы алгоритма для
задач пакетной маршрутизации в моделях компьютерной сети и управления системой багажных
конвейеров. Также будет проведено экспериментальное сравнение алгоритма с
существующими алгоритмами маршрутизации и управления конвейерной системой.

%% Начало содержательной части.
\chapter{Обзор предметной области}

%% Так помечается начало обзора.
\startrelatedwork

\section{Задача управления конвейерной системой}\label{problem-statement}

Конвейерные системы имеют широкий спектр применения во многих различных областях
человеческой деятельности. Соответственно, существует множество различных видов
конвейеров и конвейерных систем. С инженерной точки зрения конвейерные системы
можно различать по принципу действия и по конструктивным характеристикам
--- их можно подразделить на ленчатые, пластинчатые, тележные и прочие.
Также конвееры различают по назначению, то есть по типу перемещаемых грузов и по
сфере применения.

С точки зрения математического моделирования конвейерной системы наиболее
осмысленно разделять конвейеры на два крупных множества -- для
перемещения штучных грузов и для перемещения насыпных (или кусковых) грузов.
В первом случае перемещаемые по системе грузы можно моделировать как множество
дискретных объектов, где каждый объект имеет свою определенную позицию, во
втором случае так делать нельзя. Также эти типы конвейеров решают разные задачи,
и соответсвенно, требуют различных подходов к оптимизации своей работы.

В данной работе будет рассмотрена задача управления конвейерной системой для
перемещения штучных грузов. В качестве конкретной рассматриваемой задачи выбрана
задача управления системой ленчатых (пластинчатых) конвейеров для
транспортировки багажа в аэропорту. Для проведения экспериментов 
была разработана имитационная модель конвейерной системы, описанная в Приложении
\ref{apx:simulators}.

При перемещении штучных грузов с помощью конвейерной системы очевидным критерием
оптимизации является скорость доставки груза до точки назначения. Для систем с
нелинейной топологией (какими, например, являются системы для транспортировки
багажа), кроме того, необходимо решать задачу избежания столкновений между
перемещаемыми объектами, и, более того, эта задача является приоритетной.
И для всех без исключения конвейерных систем, включая и системы для перемещения
насыпных грузов, актуальна задача оптимизации энергопотребления.

Далее мы рассмотрим эти три подзадачи и подходы к их решению по отдельности.

\subsection{Маршрутизация}\label{overview:routing}

Задача оптимизации скорости доставки груза до точки назначения с помощью
конвейерной системы по большей части сводится к задаче маршрутизации. В общем
случае, задача маршрутизации --- это задача поиска множества путей наименьшей
стоимости $P = \{(p^i, p_1^i, ... , p_k^i, d^i)\}_{i=0}^N$ в графе $G = (V, E)$ при
заданном множестве пар точек входа и точек назначения
$Q = \{(p^i, d^i)\}_{i=0}^N$ и некоторых заданных ограничениях на пути. Как
правило, за стоимость пути берется время его прохождения некоторым объектом,
находящемся в заданной точке входа --- например, время доставки пакета по адресу
в компьютерных сетях.

Большинство исследований, посвященных маршрутизации, посвящены исследованию
маршрутизации именно в компьютерных сетях, что неудивительно, учитывая ее
колоссальную практическую значимость. Наиболее важные в рамках данной работы
алгоритмы сетевой маршрутизации будут рассмотрены в разделе
\ref{overview:networks}. Сейчас мы рассмотрим существующие подходы к
маршрутизации в конвейерных системах, в особенности --- в системах
транспортировки багажа.

\subsubsection{Маршрутизация для насыпных конвейеров}\label{overview:japans}

В конвейерных системах для перемещения насыпных грузов задача маршрутизации
возникает, например, в тех случаях, когда нужно сортировать по разным точкам
назначения несколько типов разных материалов, поступающих из одного источника.
Такая задача часто возникает в рамках работы промышленных предприятий, например,
металлургических заводов.

Существуют методы оптимального решения этой задачи, основанные на ее
представлении в виде задачи линейного программирования
\cite{ago2007simultaneous}. Эти методы предполагают, что все запросы за
некоторый временной интервал планирования $T$ заранее известны, и подразумевают
централизованный расчет стратегии работы для всей системы. К тому же, в силу
существенно различных специфик работы между насыпными и штучными конвейерами,
нельзя сходу применить эти методы к задаче маршрутизации в штучных конвейерных
системах.

\subsubsection{Маршрутизация для штучных конвейеров}

Задача маршрутизации в конвейерных системах для перемещения штучных грузов очень
похожа на задачу маршрутизации в компьютерных сетях, если представить
конвейерную сеть в виде направленного графа, где узлами графа являются точки
назначения (входы, выходы и какие-либо промежуточные точки на пути грузов), а
ребрами являются секции конвейеров между сочленениями. Так как методы
маршрутизации в компьютерных сетях хорошо изучены и развиваются очень давно,
имеет смысл применять их также и к конвейерным сетям.

Среди конвейерных систем, перемещающих штучные грузы, одними из наиболее
распространных являются системы для транспортировки багажа. Они предназначены
для доставки багажа со стоек регистрации, где его оставляют пассажиры, к
разгрузочным портам терминалов вылета, а также от терминалов прибытия к местам
выдачи багажа.

В современных крупных аэропортах, где багаж необходимо перемещать на большие
расстояния, системы для транспортировки багажа часто состоят не только из
конвейеров, но также и из автоматических рельсовых тележек (\textit{англ.}
destination coded vehicles, DCVs) \cite{fay2005decentralized, tarau2010model}.
В таких случаях конвейеры перемещают багаж только до тележек и обратно. Однако,
чисто конвейерные системы транспортировки дешевле и проще в установке, поэтому
они остаются востребованными, особенно для небольших аэропортов
\cite{vickers1998passenger}.

\begin{figure}[!h]
  \caption{Отклонитель отклоняет сумку на смежный конвейер}\label{diverter-pic}
  \centering
  \includegraphics[width=0.6\textwidth]{diverter-photo}
\end{figure}

Ключевыми элементами конвейерной системы, помимо собственно конвейеров, являются
сканеры багажной бирки (\textit{англ.} scanner) и отклонители (\textit{англ.}
diverter) (рис. \ref{diverter-pic}). Последние играют роль агентов, выполняющих
маршрутизацию сумок в системе.

Отличительной чертой этих систем является невозможность применения к ним
статических методов оптимального контроля наподобие метода маршрутизации для
насыпных конвейеров, описанного в разделе \ref{overview:japans}. Это связано с
тем, что все запросы маршрутизации за некоторый период планирования $T$ не могут
быть известны заранее, так как
пассажиры регистрируют багаж на разные рейсы в случайном порядке, и информация о
наличии конкретной сумки появляется в системе только после прохождения сумкой
сканера. \cite{hallenborg2007decentralized, de1994baggage}. Таким образом,
стратегия маршрутизации должна быть рассчитана для каждой новой сумки в
отдельности.

В существующих конвейерных системах по большей части применяется статический
подход к маршрутизации, когда для каждой новой сумки весь маршрут до конечной
точки назначения рассчитывается в момент ее сканирования
\cite{johnstone2009status}.
В некоторых системах применяется более динамический подход, аналогичный
маршрутизации в конвейерных сетях, когда кратчайший маршрут до точки назначения
рассчитывается при приближении сумки к очередному отклонителю (\textit{англ.}
diverter)\cite{hallenborg2007decentralized}. Однако, в обоих случаях стоимость
пути рассчитывается только с учетом длин конвейеров, например, с помощью
алгоритма Дейкстры. Второй подход в этом случае имеет больше смысла, чем первый,
только тогда, когда сумка может быть доставлена в любую из нескольких точек
назначения (например, в случае, если сумка должна быть доставлена к одному из
множества рентгеновских сканеров для проверки службой безопасности), и когда в
ходе работы системы какие-либо из этих точек могут стать недоступны (например,
когда выбранный ранее сканер занят другой сумкой).

В большинстве случаев, в системах для транспортировки багажа контроллеры
отклонителей на сочленениях не производят расчет стратегии, а только посылают
сообщения об обнаружении подъезжающей сумки центральному логическому узлу,
который, в свою очередь, посылает обратно сообщение с действием, которое
требуется совершить (сместить сумку/не смещать)
\cite{hallenborg2007decentralized, johnstone2009status}. Это еще одно
существенное отличие от маршрутизации в компьютерных сетях, так как
централизованная маршрутизация в компьютерных сетях довольно редко имеет смысл
(как правило, только в особых случаях, имеющих отношение к
программно-определенным сетям (\textit{англ.} software-defined networks, SDNs)
\cite{mao2017routing, wang2018machine}.

Однако, централизованный подход к управлению всегда подразумевает наличие
центральной точки отказа для всей системы --- собственно логического
контроллера. Очевидно, что это нежелательное свойство для киберфизических
систем, поэтому децентрализованные подходы к управлению являются более
предпочтительными. В следующем подразделе мы подробно рассмотрим существующий
такой подход.

\subsubsection{Децентрализованная маршрутизация в системе транспортировки
  багажа}\label{vyatkin-method}

Децентрализованный метод управления конвейерной системой для транспортировки
багажа был предложен в работах \cite{black2009intelligent, vyatkin-controllers}.
В этих работах описана архитектура и логика контроллеров отдельных элементов
системы для транспортировки багажа (конвейеры, сканеры, отклонители и т. д.) а
также протокол их взаимодействия на основе стандарта IEC 61499 \cite{IEC61499}.
Предложенная в них архитектура обладает следующими свойствами:

\begin{figure}[!h]
  \caption{Схема децентрализованной архитектуры конвейера}\label{vyatkin-convs}
  \centering
  \includegraphics[width=\textwidth]{vyatkin-conveyors-illustration}
\end{figure}

\begin{itemize}
\item Каждый отдельный конвейер имеет свой логический контроллер
\item На конвейере в различных позициях могут находиться:
  \begin{itemize}
  \item сочленения с входящими конвейерами (\textit{англ.} mergers)
  \item сочленения с исходящими конвейерами, оборудованные отклонителями(\textit{англ.} diverters)
  \end{itemize} 
\item Перед каждым сочленением, как входящим, так и исходящим, установлен
  детектор, определяющий позицию сумки.
\item Сочлененные конвейеры соединены между собой коммуникационным интерфейсом и
  могут посылать друг другу сообщения.
\end{itemize}

На рисунке \ref{vyatkin-convs} представлена схема этой архитектуры.

Большая часть этих работ фокусируется на
технических деталях реализации логики контроллеров в рамках упомянутого
стандарта и изучением преимуществ его использования в сравнении с более старыми
архитектурными стандартами для программных контроллеров в киберфизических
системах (таких как IEC 61131-3 \cite{IEC61131}).

С точки зрения непосредственно
логики маршрутизации, в работах используется немного модифицированный
распределенный алгоритм Беллмана-Форда \cite{bellman-ford}, по сути, почти в
точности повторяющий логику дистанционно-векторных алгоритмов сетевой
маршрутизации (что будут рассмотрены более подробно в разделе
\ref{overview:networks:dv}). Работа \cite{vyatkin-controllers} отдельно
демонстрирует, что этот алгоритм способен адаптировать маршруты в случае поломок
отдельных конвейеров, точно так же, как дистанционно-векторный алгоритм в
компьютерных сетях способен адаптироваться к обрывам соединений. Это, вкупе с
отсутствием единой точки отказа, выгодно выделяет предложенный
децентрализованный подход на фоне общепринятых.

\subsection{Избежание столкновений}\label{overview:collisions}

Важнейшим ограничением на работу конвейерной системы любого предназначения
является недопущение столкновения перемещаемых объектов. Это ограничение
применимо и к конвейерным системам для насыпных грузов, в тех случаях, когда по
системе перемещаются грузы разного типа, смешение которых недопустимо.

Для систем, в которых для маршрутизации применяется расчет оптимальной стратегии
действий для заданного множества объектов в заданный промежуток времени, как в
работе \cite{ago2007simultaneous}, ограничение на запрет столкновений объектов
(или потоков материалов) можно выразить как одно из ограничений в задаче
линейного/квадратичного программирования (или же как один из членов
оптимизируемой функции с большим коэффициентом), чтобы выполненная глобальная
стратегия, будучи правильно исполненной, гарантированно не привела к столкновениям.

Однако, как уже было сказано, такой подход неприменим для решения задачи
управления системой транспортировки багажа. Вследствие этого в них, впрочем, как
и в других транспортных системах, применяются другие подходы.

Подход, основанный на взаимной координации скоростей соединяющихся конвейеров,
описан во многих источниках \cite{black2009intelligent, schafer2011material}.
Описания в них, в сущности, отличаются лишь глубиной и характером технических
деталей. Суть подхода во всех случаях одна и заключается во взаимной
синхронизации скоростей соединяющихся конвейеров при приближении объектов на них
к сочленению.

\begin{figure}[!h]
  \caption{Схема взаимодействия соединяющихся конвейеров при приближении сумки к
  сочленению}\label{collision-avoidance-1}
  \centering
  \includegraphics[width=\textwidth]{collision-avoidance-1}
\end{figure}

Для конкретики рассмотрим децентрализованный подход, описанный в
\cite{black2009intelligent}. Как было указано в предыдущем разделе, в нем
подразумевается, что каждый конвейер имеет собственный контроллер. Каждый
такой контроллер поддерживает модель положения сумок на соответствующем
конвейере. Такая модель поддерживается путем получения сигналов от детекторов,
стоящих в конце каждой секции конвейера, а также путем передачи сообщений о
входящих/исходящих сумках между соседними конвейерами.

В задачу системы входит поддержание установленного минимального зазора $D$ между
сумками. Если начало конвейера $C2$ находится, согласно текущей модели положения
сумок, на расстоянии меньшем $D$ от некоторой сумки, то въезд другой сумки на
начало конвейера запрещен. Конвейер сообщает об этом путем посылки специального
сигнала RCVRDY = FALSE предыдущему конвейеру $C1$, который, в свою очередь,
выставляет соответствущий флаг EXITRDY = FALSE. Аналогичным образом работают
сигналы MERGERDY и DIVERTRDY в случаях соединения конвейеров в сочленениях.

Если при приближении сумки в выходу или отклонителю соответствующий флаг
EXITRDY/DIVERTRDY имеет значение FALSE, то конвейер останавливается, не
допуская, чтобы сумка достигла конца текущей секции до тех пор, пока значение
флага не станет TRUE. Кроме того, конвейер выставляет все свой флаг RCVRDY и все
флаги MERGERDY, сообщая предыдущим конвейерам, что он останавливается и что на
него не следует перемещать сумки. При приближении сумок к такому конвейеру
предыдущие конвейеры будут также останавливаться, не допуская перемещение сумок
на него до тех пор, пока конвейер не возобновит работу. Таким образом
достигается, что между сумками, достигшими одного и того же сочленения,
соблюдается разумное расстояние, что исключает их столкновение.

В данной работе для избежания столкновений сумок будет использован именно этот
метод с небольшими модификациями в сочетании с разработанным алгоритмом маршрутизации.

\subsection{Оптимизация энергопотребления}\label{overview:energy}

Оптимизация энергопотребления конвейерных систем является крайне важной в
глобальном смысле задачей, так как на работу промышленных конвейерных систем
уходит до 6\% всей потребленной электроэнергии в мире \cite{halepoto2016design}.

Один из подходов к оптимизации энергопотребления --- усовершенствование
физического оборудования: разработка новых типов лент, смазок и натяжных колес
конвейеров в целях снижения побочных затрат энергии на трение и шум
\cite{staniak1996energy}. Еще один подход, не отрицающий первого --- снижение
энергопотребления путем контроля поведения конвейера.

Простейшим подходом к энергосбережению в конвейерных системах является
метод оптимального выключения (\textit{англ.} optimal switching control) ---
выключение конвейера в то время, когда он не выполняет полезной работы. Этот
подход, вообще говоря, применим не только к конвейерам, но и вообще к любому
автоматизированному оборудованию. Так, в работе
\cite{middelberg2009optimal} предложен метод оптимизации энергопотребления
разгрузочных конвейеров угольной шахты, основанный на методе оптимального
контроля, который определяет оптимальные временные промежутки для включения и
выключения конвейеров. Там же приведена формулировка этой задачи в обобщенной
форме как задачи минимизации функции

\begin{equation}\label{energy:opt-switching-J}
  J = \int_{t_0}^{t_1} \! \sum\limits_{i=1}^n P_i(t) u_i(t) p(t) \mathrm{d}t
\end{equation}

, где $[t_0, t_1]$ --- временной интервал планирования, $n$ --- количество
конвейеров, $P_i(t)$ --- энергопотребление $i$-го конвейера в момент времени
$t$, $p(t)$ --- функция, которая задает стоимость электроэнергии во время $t$
(дана как условие задачи), и

\begin{equation}\label{energy:opt-switching-u}
  u_i(t) = \begin{cases}
    1, & \text{if switched on}\\
    0, & \text{if switched off}
  \end{cases}
\end{equation}

--- контролируемая величина, определяющая, включен или нет конвейер $i$ в момент
времени $t$. Минимизация функции $J$ производится в соответствии с некоторыми
ограничениями вида

\begin{equation}\label{energy:opt-switching-g}
  g(u(t), t) \leq 0
\end{equation}

, которые выражают операционные требования к системе (конвейеры должны
переместить груз, то есть они должны быть включены на момент поступления груза и
в то время, когда он находится на конвейере).

В случае системы транспортировки багажа, как уже было сказано, расписание
прибытия сумок не может быть известно заранее, что не позволяет использовать
данный подход к оптимизации энергопотребления. Однако, никто не запрещает
использовать простые эвристики, такие как остановка и выключение конвейера
спустя некоторое время после того, как на нем не осталось сумок
\cite{mukhutdinov2019multi}.

В случае, если включенный конвейер потребляет константное количество
электроэнергии за единицу времени, метод оптимального переключения является
наилучшим. Однако, на практике это не так.
На текущую энергоэффективность конвейера в каждый
конкретный момент времени влияет множество факторов: КПД двигателя, трение
ленты, масса перемещаемого груза, скорость движения и так далее. Зависимость
энергопотребления от этих параметров можно выразить с помощью математической
модели.

В целях проектирования и производства эффективного конвейерного
оборудования были разработаны стандартизированные модели расчета планируемого
энергопотребления, такие как ISO 5048 \cite{ISO5048}, DIN 22101 \cite{DIN22101}
и JIS B 9905 \cite{JISB8805}. Эти модели предназначены для конвейеров,
перемещающих насыпные грузы, и учитывают большое количество точных параметров
конструкции механизма, такие как масса вращающихся деталей, плотность
конвейерной ленты и так далее.

Как правило, ввиду своей сложности, данные модели не используются для
моделирования энергопотребления системы при решении задачи оптимизации. Для
оптимизации энергопотребления в работе \cite{zhang2011modeling} была предложена
приближенная аналитическая модель. Эта модель также предназначена для
конвейеров, перемещающих насыпные грузы, и выражает текущее энергопотребление
конвейера как:

\begin{equation}\label{energy:zhang-model}
  P(V, T) = \frac{1}{\eta} \left( \theta_1 VT^2 + \theta_2 V + \theta_3 \frac{T^2}{V}
  + \theta_4 T + \frac{V^2T}{3.6} \right)
\end{equation}

, где $V$ --- это текущая скорость конвейера, $T$ --- масса поступающего на вход
конвейера за единицу времени вещества, $\eta$ --- КПД системы, а $\theta_1$,
$\theta_2$, $\theta_3$ и $\theta_4$ --- коэффициенты, рассчитываемые из
постоянных характеристик конвейера, используемых в модели ISO 5048. 

В работе \cite{halepoto2016design} приводится простая обобщенная модель
энергопотребления конвейера для транспортировки штучных грузов:

\begin{equation}\label{energy:linear-model}
  P(V) = \frac{M_r(m_L)V}{\eta}
\end{equation}

, где $V$ --- это текущая скорость конвейера, $M_r$ --- это величина полного
сопротивления движению, зависящая от суммарной массы находящихся на конвейере
объектов $m_L$ и константных характеристик, таких как длина конвейера, его
ширина, и прочих.

Видно, что в этой модели энергопотребление линейно зависит от
скорости конвейера (если не учитывать тот факт, что от скорости конвейера
зависит скорость изменения $m_L$). В модели \ref{zhang-model} тоже содержится
линейный член от $V$, что побуждает прийти к выводу, что в правдоподобных
моделях энергопотребления конвейера зависимость энергопотребления от скорости
похожа на линейную. Таким образом, если конвейер способен произвольно изменять
свою скорость, в целях снижения энергопотребления также имеет смысл регулировать
скорость конвейера, а не просто по возможности его выключать.

В разработанной в рамках данной работы имитационной модели конвейерной системы
для подсчета ``реальных'' затрат на электроэнергию используется модифицированная
под нужды штучных конвейеров модель \ref{energy:zhang-model}.

%% \section{Методы оптимального контроля}

%% MPC \cite{luo2015energy}

%% \begin{definition-ru}
%%   \textbf Управление с прогнозируемыми моделями (\textit{англ.} model predictive
%%   control, MPC) --- это...
%% \end{definition-ru}

%% TBD

\section{Алгоритмы сетевой маршрутизации}\label{overview:networks}

Почти все существующие алгоритмы пакетной маршрутизации были разработаны для
маршрутизации пакетов в компьютерных сетях. Большинство алгоритмов маршрутизации
в компьютерных сетях, применяемых на практике, относятся к одному из двух
семейств алгоритмов --- дистанционно-векторные (distance-vector) \cite{arpanet-orig} или
состояния каналов связи (link-state) \cite{link-state-arpanet}.
Концептуально все алгоритмы внутри каждого из этих семейств одинаковы, и различаются только
техническими деталями реализации, обусловленными спецификой конкретной узкой
сферы применения. Поэтому мы не будем рассматривать алгоритмы каждого семейства
по отдельности, а рассмотрим только концепции в целом.

\subsubsection{Дистанционно-векторные алгоритмы}\label{overview:networks:dv}

Идея дистанционно-векторных алгоритмов (\textit{англ.} distance-vector algoritms) заключается в
следующем:

\begin{itemize}
\item Каждый маршрутизатор $s$ в сети хранит таблицу, в которой для каждого другого узла
  сети $d$ хранится следующая информация:
  \begin{itemize}
  \item Предполагаемое кратчайшее расстояние от $s$ до $d$
  \item Сосед $n$, которому нужно отправить пакет, чтобы пакет прошел по
    кратчайшему пути до узла $d$.
  \end{itemize}
\item Периодически каждый маршрутизатор рассылает свою версию таблицы кратчайших
  расстояний всем своим соседям
\item При получении вектора кратчайших расстояний от соседа маршрутизатор $s$
  сравнивает его поэлементно с текущей версией. Если оказывается, что наименьшая
  стоимость пути от соседа $n$ до узла $d$, сложенная c оценкой стоимости ребра
  $(s, d)$ меньше, чем наименьшая стоимость пути от $s$ до $d$ в текущей
  таблице, то значение в текущей таблице обновляется, и наилучшим соседом для
  отправки пакета в узел $d$ становится сосед $n$.
\end{itemize}

\begin{figure}[!h]
  \caption{Иллюстрация работы distance-vector алгоритма}\label{rip-img}
  \centering
  \includegraphics[scale=1.5]{dv-failure-2}
\end{figure}

Как можно видеть, дистанционно-векторный алгоритм является, в сущности,
распределенной версией алгоритма Беллмана-Форда поиска кратчайшего пути в
графе \cite{bellman-ford}.

Различные реализации дистанционно-векторного метода различаются, в частности,
оценками стоимости соединений в сети. Так, например, протокол RIP \cite{rip-rfc} просто
оценивает стоимость каждого соединения в 1, а IGRP \cite{igrp-patent} оценивает
стоимость соединений исходя из оценок задержки и пропускной способности.

Преимуществами дистанционно-векторных алгоритмов являются простота реализации и
низкие требования к памяти и вычислительной мощности. Недостатками же являются
низкая скорость распространения информации по сети и сложности с приспособлением
под изменяющуюся топологию (проблема count-to-infinity). Этих проблем
удается избежать при применении другого распространенного подхода --- алгоритмов
на основе состояния канала связи. 

\subsubsection{Алгоритмы состояния канала связи}\label{overview:link-state}

В отличие от дистанционно-векторных алгоритмов, в алгоритмах состояния канала связи
(\textit{англ.} link-state) каждый узел сети хранит у себя модель всей сети в
виде графа. Рассмотрим шаги алгоритма подробнее:

\begin{itemize}
\item Каждый маршрутизатор периодически проверяет состояние соединений до
  соседей
\item При обнаружении обрыва какого-либо соединения алгоритм удаляет это
  соединение из собственного графа и рассылает соседям новую версию состояния
  соединений до них
\item Соседи обновляют собственные версии графов в соответствии с полученной
  информацией и пересылают сообщение дальше
\item Чтобы избежать зацикливания сообщений об обновлении состояния, каждое
  сообщение снабжается \textit{номером версии}. Маршрутизатор $n$ игнорирует
  сообщение от маршрутизатора $n$, если номер версии этого сообщения меньше или
  равен предыдущему.
\end{itemize}

\begin{figure}[!h]
  \caption{Иллюстрация работы link-state алгоритма}\label{ospf-img}
  \centering
  \includegraphics[scale=1.5]{ls-twoway}
\end{figure}

Имея информацию обо всей сети в целом, маршрутизатор может рассчитать кратчайшие
пути до всех остальных узлов. Обычно для этого используется алгоритм
Дейкстры \cite{dijkstra}. 

Link-state алгоритмы обладают способностью адаптироваться под изменения
топологии сети гораздо быстрее, чем distance-vector алгоритмы за счет
несколько более сложной реализации и чуть больших затрат по памяти и
вычислительной мощности. Это обуславливает то, что на данный момент именно
link-state протоколы, такие как OSPF \cite{ospf-rfc}, доминируют в сетевой
маршрутизации. Однако даже в решении задачи сетевой маршрутизации link-state
алгоритмы в чистом виде не лучшим образом адаптируются к повышению нагрузки в
сети. Рассматриваемые в дальнейшем другие алгоритмы, основанные на принципе
обучения с подкреплением, справляются с задачей адаптации к
изменчивой нагрузке лучше.

\subsubsection{Q-routing}\label{q-routing-desc}

Среди других подходов особый интерес представляют подходы на основе обучения с
подкреплением. Первым алгоритмом маршрутизации, основанным на этой идее, стал
алгоритм Q-routing \cite{q-routing-orig}. Принцип его работы таков:

\begin{itemize}
\item Каждый маршрутизатор $x$ хранит $Q_x(d, y)$ --- оценку минимального
  времени в пути до узла $d$, если следующим узлом на пути является сосед $y$.
  Очевидно, что $\forall y : Q_x(x, y) = 0$ 
\item Пакет, который необходимо доставить в узел $d$, отправляется соседу
  $y = \argmin\limits_{(x, y) \in E} Q_x(d, y)$
\item При получении пакета узел $y$ отправляет узлу $x$ время получения $t_r$ и
  собственную оценку оставшегося времени в пути
  $t = \min\limits_{(y, z) \in E} Q_y(d, z)$
\item Зная время отправления пакета $t_s$ и получив $t_r$ и $t$, узел $x$
  обновляет собственную оценку по формуле:
  $Q_x(d, y) = \alpha((t_r - t_s) + t - Q_x(d, y)) + Q_x(d, y)$,
  где $\alpha$ --- это learning rate, параметр алгоритма.
\end{itemize}

Было показано, что этот алгоритм способен хорошо адаптироваться к изменениям в
топологии сети и интенсивности трафика. Такие его модификации, как dual
Q-routing \cite{dual-q-routing} и predictive Q-routing \cite{predictive-q-routing}
демонстрируют еще более высокое качество маршрутизации. Однако по сравнению с
distance-vector или link-state методами данные алгоритмы используют гораздо
больше служебных сообщений (служебный пакет на каждую пересылку целевого
пакета), что ограничивает их применение в реальных высоконагруженных
компьютерных сетях.

Однако в задачах маршрутизации вне контекста компьютерных сетей это перестает
быть проблемой, так как целевые \enquote{пакеты}, такие как чемоданы на конвейере,
и служебные сообщения в таких задачах являются объектами разной природы и
передаются по разным каналам, причем служебные сообщения по сравнению с целевыми
\enquote{пакетами} доставляются мгновенно. Эти обстоятельства делают применение
алгоритмов обучения с подкреплением в таких задачах более привлекательным.


%% \subsection{Применение машинного обучения в сетевой маршрутизации}

%% TBD

%% \subsubsection{Программно-определяемые сети (SDN)}

%% TBD

%% \subsection{Другие подходы}

%% Для полноты обзора приведем еще несколько примеров.

%% Идея использования нейросетей для решения задачи маршрутизации не нова. В
%% работах \cite{ali-nn-routing, araujo2001neural} для решения задачи поиска кратчайшего пути в графе
%% используются нейронные сети Хопфилда. Однако, эти исследования преследовали цель
%% ускорения вычисления кратчайшего пути за счет аппаратной реализации нейросети,
%% что кардинально отличается от цели текущей работы.

%% Еще одним интересным подходом является AntNet \cite{di1998antnet}. Это алгоритм,
%% построенный на идее исследования состояния сети с помощью специальных
%% пакетов-\enquote{агентов}. Алгоритм показал хорошие результаты в ходе исследований, но
%% не получил широкого применения, вероятно, в силу уже массового к тому времени
%% распространения link-state и distance-vector протоколов.

\section{Применение обучения с подкреплением к поставленной задаче}

В большинстве случаев при разработке процессов управления киберфизическими
системами используются устоявшиеся подходы из областей теории операций и теории
управления. Для управления простыми процессами используются
PID-контроллеры\cite{aastrom2006advanced}, для сложных процессов разрабатываются
математические модели, которые позволяют свести задачу управления к задаче
оптимизации некоторой целевой функции, которую можно решать известными
математическими методами.

Принцип \textit{управления с прогнозируемыми моделями}
(\textit{англ.} model predictive control, MPC) как раз заключается в решении
такой оптимизационной задачи на несколько шагов вперед, используя на каждом шагу
после первого не реальные наблюдаемые параметры процесса, а предсказанные с
помощью модели этого процесса. Этот принцип применяется как для задач управления
промышленными конвейерными сетями \cite{cataldo2016dynamic, luo2015energy}, так
и для задач управления системами транспортировки багажа на основе DCV
\cite{tarau2010model, zeinaly2015integrated} (но авторам не удалось обнаружить
убедительных работ, применяющих MPC к задаче управления именно конвейерной
системой транспортировки багажа).

Однако, этот метод имеет очевидные недостатки, такие как:

\begin{itemize}
\item необходимость разработки собственно модели процесса
\item вычислительная сложность, быстро растущая при повышении сложности модели и
  увеличении горизонта планирования
\end{itemize}

Таким образом, его сложно применять в тех случаях, когда не получается придумать
вычислительно эффективную модель процесса или когда количество параметров
процесса слишком велико.

В отличие от MPC, методы \textit{обучения с подкреплением} не требуют построения
предсказательных моделей, а вместо этого корректируют стратегию поведения,
основываясь на опыте взаимодействия с реальным процессом. В частности, подход
глубокого обучения с подкреплением --- с использованием нейросетей в качестве
обучающихся агентов --- демонстрирует ранее невиданные результаты в решении
задач, ранее считавшихся нерешаемыми, таких как игра в Го
\cite{silver2016mastering}. Это мотивирует попытки применения методов глубокого
обучения с подкреплением ко все более разнообразным задачам. В этой работе
мультиагентное глубокое обучение с подкреплением будет применено к задаче
управления конвейерной системой.

В следующих подразделах будут введены ключевые понятия из этой области,
осуществлена постановка задачи в соответствующих терминах и проведен краткий
обзор существующих методов и применений глубокого обучения с подкреплением.

\subsection{Термины и понятия}

\begin{definition-ru}
  \textbf{Обучение с подкреплением} (\textit{англ.} reinforcement learning, RL) --- вид машинного
  обучения, в котором \textit{агент} (agent) каждый момент времени $t$ 
  взаимодействует со \textit{средой} (environment), находящейся в
  \textit{состоянии} (state) $s_t \in \mathcal{S}$ путем выбора
  \textit{действия} (action) $a \in \mathcal{A}_{s_t}$ и получения
  \textit{вознаграждения} (reward) $r_{t+1} \in \Bbb{R}$ c переходом в новое
  \textit{состояние} $s_{t+1}$.
\end{definition-ru}

\begin{figure}[!h]
  \caption{Схема взаимодействия агента и среды в обучении с подкреплением}\label{rl-scheme}
  \centering
  \includegraphics[scale=0.5]{rl-scheme}
\end{figure}

\begin{definition-ru}
  \textbf{Марковский процесс принятия решений} (\textit{англ.} Markov decision process, MDP) ---
  это кортеж
  $(\mathcal{S}, \mathcal{A}_s, P, r, \gamma)$, где

  \begin{itemize}
  \item $\mathcal{S}$ --- конечное множество состояний
  \item $\mathcal{A}_s$ --- конечное множество действий, доступных из состояния
    $s$
  \item $P(s' | s, a)$ --- вероятность того, что действие $a$ в состоянии $s$
    приведет к переходу в состояние $s'$ в следующий момент времени.
  \item $r : \mathcal{S} \times \mathcal{A}_s \rightarrow \Bbb{R}$ ---
    вознаграждение за действия $a$ в состоянии $s$
  \item $\gamma \in [0, 1]$ --- \textit{скидочный коэффициент} (discount factor),
    управляющий соотношением между важностью текущих вознаграждений и будущих вознаграждений.
  \end{itemize}
\end{definition-ru}

\begin{definition-ru}
  \textbf{Оптимальной стратегией} для данного марковского процесса принятия
  решений называется такая функция выбора действий $\pi : \mathcal{S} \rightarrow \mathcal{A}_s$,
  что взвешенная сумма вознаграждений
  \begin{equation}\label{eq:reward-sum}
    \sum\limits_{t=0}^{\infty} {\gamma^t r_{\pi(s_t)}(s_t, s_{t+1})}
  \end{equation}
  максимальна.
\end{definition-ru}

\begin{definition-ru}
  \textbf{Частично наблюдаемый марковский процесс принятия решений} (Partially
  observed Markov decision process, POMDP) --- это кортеж
  $(\mathcal{S}, \mathcal{A}_s, P, R, \Omega, O, \gamma)$, где
  \begin{itemize}
  \item $\mathcal{S}$ --- конечное множество состояний
  \item $\mathcal{A}_s$ --- конечное множество действий, доступных из состояния $s$
  \item $P(s' | s, a)$ --- вероятность перехода из $s$ в $s'$ при выполнении
    действия $a$
  \item $r : \mathcal{S} \times \mathcal{A}_s \rightarrow \Bbb{R}$ ---
    вознаграждение за действие $a$ в состоянии $s$.
  \item $\Omega$ --- множество \textit{наблюдений}
  \item $O(o | s', a)$ --- вероятность получения наблюдения $o$ при переходе в
    истинное состояние $s'$ в результате действия $a$. 
  \end{itemize}
\end{definition-ru}

Определение оптимальной стратегии для частично наблюдаемого марковского процесса
аналогично таковому для обычного.

Для марковских процессов в условиях известности всех компонентов, включая $P$,
$r$ и $O$ существуют детерминированные методы нахождения оптимальной стратегии.
Однако найти оптимальную стратегию можно и в условиях неизвестности $P$, $R$ и $O$.

\begin{definition-ru}
  \textbf{Q-обучение} (\textit{англ.} Q-learning) \cite{q-learning-orig} --- это метод нахождения
  оптимальной стратегии для марковского процесса принятия решений, не требующий
  информации о функции $r$ и распределении $P$. Метод заключается в оценке
  \textit{функции полезности} (action-value function)
  $Q(s,a)$. Функция полезности изменяется при каждом предпринятом действии $a$ с
  переходом из состояния $s$ в $s'$ по следующей формуле:

  \begin{equation}\label{eq:q-learning}
    Q(s, a) = Q(s, a) + \alpha \left( r +
    \gamma \cdot \max\limits_{a \in \mathcal{A}_{s'}} - Q(s', a) \right)
  \end{equation}
\end{definition-ru}

Известно, что для любого конечного марковского процесса принятия решений
Q-обучение находит оптимальную стратегию, т. е. $Q(s, a) \xrightarrow{t
  \rightarrow \infty} Q^*(s, a)$, и $\pi(s) = \argmax\limits_{a \in
  \mathcal{A}_s} {Q^*(s, a)}$ --- оптимальная стратегия.

\subsection{Формулировка задачи в терминах обучения с подкреплением}\label{rl-task-formulation}

В разделе \ref{problem-statement} задача управления конвейерной системой была
разбита на три подзадачи: маршрутизацию, избежание столкновений и
энергосбережение. Там же было указано, что недопустимость столкновений является
наиболее строгим ограничением в задаче, и был описан простой и надежный
существующий децентрализованный метод, гарантирующий отсутствие столкновений
\cite{black2009intelligent}. В связи с этим будем в нашем методе пытаться решать
только первую и третью подзадачи, и использовать его в комбинации с описанным
методом избежания столкновений для решения всей задачи целиком.

Задача маршрутизации заключается в минимизации среднего времени сумки в пути до
точки выгрузки:

\begin{equation}\label{eqs:J_r}
  J_R = \frac{1}{N} \sum\limits_{i=0}^{N} (t_d^i - t_s^i)
\end{equation}

, где $t_s^i$ --- время появления $i$-ой сумки в системе (сканирования), и
$t_d^i$ --- время ухода $i$-ой сумки в точку выгрузки, $N$ --- общее количество
сумок.

Задача энергосбережения заключается в минимизации суммарного количества
потребленной энергии:

\begin{equation}\label{eqs:J_e}
  J_E = \int_0^T \! \sum\limits_{j=0}^{M} p_j(t) \; \mathrm{d}t
\end{equation}

, где $p_j(t)$ --- удельное энергопотребление конвейера $j$ в момент времени $t$.

Соответственно, совместную задачу маршрутизации и энергосбережения можно
представить как минимизацию функции 

\begin{equation}
  J = \theta_R J_R + \theta_E J_E
\end{equation}

, где $\theta_R$ и $\theta_E$ --- это веса приоритета, параметры задачи.
Эквивалентно для удобства можно записать

\begin{equation}
  J = J_R + \alpha J_E
\end{equation}

, где $\alpha = \frac{\theta_E}{\theta_R}$ --- приоритет оптимизации
энергопотребления.

Чтобы свести эту задачу к задаче обучения с подкреплением, то есть к задаче
поиска \textit{оптимальной стратегии}, нужно выразить $J$ в виде
(\ref{eq:reward-sum}). Чтобы это сделать, нам нужно определиться с тем, что в
системе является агентом, каково множество состояний агента $\mathcal{S}$,
каково множество действий $\mathcal{A}$ и как определена функция вознаграждения
$r : \mathcal{S} \times \mathcal{A}_s \rightarrow \Bbb{R}$.

Так как в наших целях разработка децентрализованного алгоритма, логично
предположить, что нужно рассматривать мультиагентный сеттинг, где в качестве
агента выступает контроллер отдельного конвейера, отвечающий за управление им и
отклонителями на его сочленениях, по аналогии с архитектурой, описанной в
разделе \ref{vyatkin-method}.

Если в этом случае рассматривать только функцию
энергопотребления $J_E$, и предположить, что конвейер $j$ может отслеживать
суммарное количество собственной потребленной энергии на момент времени $t$:

\begin{equation}
  P_j(t) = \int_0^t \! p_j(t) \; \mathrm{d}t
\end{equation}

, то достаточно взять в качестве действий изменение скорости и
включение/выключение питания, а в качестве состояний, скажем, текущую скорость и
количество сумок на конвейере. Тогда, выбрав некоторый период дискретизации
времени $\delta t$, мы можем определить функцию вознаграждения как
$r(s_t, a_t) = - (P_j(t + \delta t) - P_j(t))$. Тогда, взяв параметр
$\gamma = 1$, мы увидим, что формулы (\ref{eqs:J_e}) и (\ref{eq:reward-sum})
эквивалентны.

Подвох заключается в том, что в таком случае контроллер конвейера быстро
выяснит, что в любой ситуации ему не стоит двигаться, так как в разделе
\ref{overview:energy} было выяснено, что энергопотребление уменьшается с
уменьшением скорости. Такое поведение конфликтует с тем, что нам необходимо
все-таки доставлять сумки до точек назначения.

Можно предложить приоритизировать перемещение сумок над снижением
энергопотребления в рамках одного конвейера: конвейер двигается с максимально
возможной скоростью всегда, когда на нем находятся сумки, и останавливается
после того, как сумок на нем не осталось. То есть, мы оставляем конвейеру из
множества действий только действия ``on''/``off'', тем самым сводя задачу
оптимизации $J_E$ к задаче оптимального выключения.

Решение этой задачи в рамках одного конвейера элементарно и заключается в
выключении конвейера спустя определенный промежуток времени $d_t$ после того,
как его покинула последняя сумка. Задержка $d_t$ нужна потому что, во-первых,
конвейер не стартует и не запускается мгновенно, а имеет некоторые периоды
разгона и торможения, а во-вторых, потому что на разгон и торможение в
реальности уходит больше энергии, чем на равномерное движение за то же время.
Поэтому останавливаться моментально после того, как последняя сумка покинула
конвейер, неоптимально.

Если мы ограничим поведение агента таким образом, то, на первый взгляд, нам
останется решить только задачу маршрутизации --- отдельно минимизировать $J_R$.
Разобъем время сумки $i$ в пути от сканера к выгрузке $t_s^i - t_d^i$ на времена
пути по отдельным секциям конвейеров:
$t_s^i - t_d^i = \sum\limits_{j=0}^{n-1} (t_{j+1}^i - t_j^i)$, где $t_j^i$ ---
это время достижения сумкой $i$ $j$-го сочленения на пути, $t_0^i = t_s^i$,
$t_n^i = t_d^i$. Тогда, рассматривая в качестве действий отклонение или
пропускание сумки на сочленении с отклонителем, можно рассмотреть в качестве
вознаграждения время в пути, которое сумка проведет до следующего отклонителя.
Тогда, на первый взгляд, выражение для $J_R$ тоже совпадет с формулой
(\ref{eq:reward-sum}) и задачу можно будет считать решенной. Однако, это не
совсем так: это приведет к тому, что каждый отдельный конвейер будет вести себя
жадно --- всегда отклонять сумки вдоль самого быстрого пути до следующего
сочленения, потому что это будет максимизировать сумму вознаграждений, которые
получает именно он. Такая стратегия далеко не всегда будет приводить к тому, что
сумки будут отправляться по скорейшему пути до точки назначения.

Если же рассмотреть в качестве формального агента в системе не
конвейер, а \textit{сумку}, и рассмотреть ее текущую позицию в системе как часть
ее наблюдаемого состояния, то для такого агента минимизация суммы выигрышей
действительно будет приводить к движению по кратчайшему пути. Значит, для этого
агента можно (потенциально) найти оптимальную стратегию маршрутизации с помощью
Q-обучения.

Конечно, сумка не может физически реализовывать логику маршрутизации. Вместо
этого это делает контроллер конвеера, на котором она сейчас находится.
Заметим также, что путь сумки в системе конечен, а значит, конечно и
количество действий сумки-агента. Это значит, что параметр $\gamma$ в
(\ref{eq:q-learning}) можно взять равным 1. Тогда эта формула примет вид:

\begin{equation}
Q_x(o_t, a_t) = Q_x(o_t, a_t) + \alpha \left( r_t +
\gamma \cdot \max\limits_{a \in \mathcal{A}_{o_{t+1}}} Q_y(o_{t+1}, a) \right)
\end{equation}

Здесь $x$ и $y$ обозначают конвейеры, между которыми переместилась сумка ($x$
может совпадать с $y$),
а $r_t$ --- это вознаграждение, полученное ей за действие перенаправления (на
самом деле, контроллером конвейера, который совершил действие перенаправления, а
именно, $x$).

Если взять в качестве $r_t$ просто время в пути между сочленениями с минусом, то
максимизация суммы $r_t$ будет эквивалентна минимизации $J_R$. Если к тому же в качестве 
наблюдения сумки взять только идентификатор текущего сочленения, то получится в
точности алгоритм Q-routing.

Мы уже определились, что если ограничить доступные действия конвейерной
ленты как ``on''/``off'', то для оптимизации энергопотребления достаточно
простой стратегии остановки с задержкой после ухода сумок с конвейера.
Значит ли это, что использование алгоритма Q-routing в неизменном виде приведет
к оптимальной оптимизации энергопотребления в конвейерной системе? Нет, это не
так: прошлые рассуждения работали при условии, что агентом в системе считается
конвейер, а не сумка. Требуется модифицировать вознаграждения, чтобы учитывать
затраты на энергопотребление при маршрутизации. 

\section{Обзор методов обучения нейросетей с подкреплением}\label{overview:nns}

Активные исследования в области обучения с подкреплением с использованием
нейросетей начались c публикации командой DeepMind алгоритма
DQN \cite{deepmind-dqn-orig}. Алгоритм показал способность эффективно обучаться
игре в классические видеоигры на эмуляторе Atari 2600. 

Алгоритм DQN базируется на методе Q-обучения. В качестве состояния нейросеть
получает на вход текущее изображение игрового экрана. Набор действий
соответствует возможному набору игровых действий.

Ключевой проблемой при использовании Q-обучения с нейросетями является то, что
метод Q-обучения в применении к марковским процессам с бесконечным числом
состояний, вообще говоря, не сходится к оптимальной стратегии. Алгоритм DQN
борется с этим обстоятельством с помощью \textit{experience replay} --- буферa
из всех встреченных четверок $(s, a, r, s')$, где $s$ ---
начальное состояние, $a$ --- действие, предпринятое в этом состоянии, $r$ ---
полученное вознаграждение, $s'$ --- следующее состояние. Этот буфер работает как
\enquote{память} нейросети: в каждый момент времени из буфера выбирается случайное
подмножество встреченных ситуаций, и нейросеть заново обучается на них,
\enquote{вспоминая} игровой опыт. Кроме этого, для стабилизации процесса обучения в
алгоритме DQN использовалась \textit{целевая нейросеть} (target network) ---
дополнительная нейросеть, предоставляющая опорные оценки для основной сети и
копирующая ее состояние раз в $k$ шагов.

В дальнейшем было изобретено множество модификаций оригинального алгоритма DQN.
Из них можно выделить модификацию с использованием приоритизированного
experience replay \cite{schaul2015prioritized}. Идея приоритизированного
experience replay заключается в том, чтобы с большей вероятностью доставать из
буфера эпизоды, сильнее всего повлиявшие на процесс обучения --- т. е. те,
где нейросеть ошибалась в своих оценках Q-функции сильнее всего.
Также были разработаны такие модификации алгоритма, как Double
DQN \cite{van2016deep}, основанный на идее двойного
Q-обучения \cite{hasselt2010double} и Dueling DQN \cite{wang2015dueling},
основанный на идее оценки Q-функции как отдельных величин --- ценности состояния
$V(s)$ и преимущества действия $A(a)$.

Также в работе \cite{hausknecht2015deep} было показано, что добавление
LSTM-слоя \cite{hochreiter1997long} в архитектуру нейросети позволяет добиться
лучших результатов при оптимизации частично наблюдаемых марковских процессов
благодаря сохранению информации о предыдущих наблюдениях в скрытом состоянии
рекуррентного слоя. В дальнейшем глубокие нейросети с рекуррентной архитектурой
показывали впечатляющие результаты в решении сложных задач, таких как игра
Doom \cite{lample2016playing}.

Одним из первых исследований по применению глубоких нейросетей в мультиагентной
среде является исследование \cite{tampuu2017multiagent}, в котором две нейросети
играли в игру Pong друг с другом. Но уже в работе \cite{foerster2016learning}
показано, что рекуррентные нейросети могут научиться пересылать друг другу сообщения для решения
совместных задач (в частности, в этом исследовании нейросети учились
разрабатывать совместную стратегию поведения для решения головоломки об узнике и
лампочке). На основе этой работы было проведено исследование
\cite{jorge2016learning}, в котором одна нейросеть обучалась
\enquote{задавать вопросы} другой, чтобы по полученным ответам угадать, какое из
изображений \enquote{загадала} другая нейросеть.

\chapterconclusion

В главе 1 была поставлена задача управления конвейерной системой. Задача была
разбита на подзадачи: маршрутизацию, избежание столкновений и оптимизацию
энергопотребления. Были рассмотрены существующие подходы к решению этих подзадач
применительно к конвейерным системам разных типов, их преимущества, недостатки и
границы применимости.

Также были рассмотрены существующие методы решения подзадачи маршрутизации
применительно к компьютерным сетям, их преимущества и недостатки.

Задача управления конвейерной системой была сформулирована в терминах обучения с
подкреплением; был намечен подход к ее решению. Также был проведен обзор
современных методов глубокого обучения с подкреплением, в том числе в
мультиагентной среде.

%% Так помечается конец обзора.
\finishrelatedwork

\chapter{Описание разработанного алгоритма}

\section{Архитектура системы и протокол взаимодействия между агентами}

В данной работе мы предполагаем децентрализованную архитектуру системы,
аналогичную той, что предложена в \cite{black2009intelligent,
  vyatkin-controllers} и частично описана в разделе \label{vyatkin-method}. 

\section{Алгоритм маршрутизации}

Так как в разделе \ref{rl-task-formulation} в процессе сведения задачи
управления конвейерной системой к задаче обучения с подкреплением получилось, по
сути, что все свелось к задаче маршрутизации, мы будем разрабатывать алгоритм в
два этапа:

\begin{enumerate}
\item Предложение нейросетевого алгоритма маршрутизации в абстрактной
  компьютерной сети, аналогичного Q-routing;
\item Проведение первичного экспериментального исследования алгоритма в модели
  абстрактной компьютерной сети;
\item Модификация предложенного алгоритма и вознаграждений для работы в
  конвейерной системе.
\end{enumerate}

Такой подход имеет следующие преимущества:

\begin{enumerate}
\item Маршрутизация в абстрактной компьютерной сети --- это почти подзадача
  маршрутизации в конвейерной сети в чистом виде, проще сначала решить подзадачу
\item Симуляция компьютерной сети существенно менее вычислительно затратна, что
  позволяет проще проводить эксперименты на начальном этапе исследования
\item Демонстрируется обобщаемость предложенного метода на более широкий класс
  задач
\end{enumerate}

\subsection{DQN-routing}

В бакалаврской выпускной квалификационной работе, выполненной автором данной
работы ранее, а также в статье \cite{mukhutdinov2019multi}, была впервые
предложена идея объединения метода Q-routing с обучением нейросетей. Результатом
такого объединения стал алгоритм маршрутизации \textit{DQN-routing}. Эта
секция посвящена краткому обзору на него.

В алгоритме DQN-routing функция $Q(s, a)$ аппроксимируется feed-forward
нейросетью с двумя скрытыми слоями по 64 нейрона (рис. \ref{nn-pic-2}). На вход
нейросети подается
текущее состояние агента $s$. В текущее состояние $s$ всегда входит кортеж $(n,
d, y_1 ... y_m)$, где $n$ --- это идентификатор (номер) текущего узла, $d$ ---
номер узла назначения текущего пакета, а $y_1 ... y_m$ --- номера соседей
текущего узла.

\begin{figure}[!h]
  \caption{DQN-routing: архитектура сети для графа из 5 узлов}\label{nn-pic-2}
  \centering
  \includegraphics[scale=0.5]{nn-2}
\end{figure}

Чтобы избежать взаимозависимости оценок Q-функции для узлов с близкими номерами, будем
использовать \textit{унитарный код}, т. е. для сети с семью узлами номер 3 будет
кодироваться как 0010000, номер 5 --- как 0000100, и т. д. Для кодирования
множества соседей будем использовать тот же принцип, т. е. множество соседей 1,
3, 4 будет закодировано как 1011000. Таким образом, размер входного
слоя нейросети составит как минимум $3n$, где $n$ --- количество узлов в сети (в
конвейерной системе узлам в сети соответствуют сочленения конвейеров, см.
Приложение \ref{apx:simulators})

Выходной слой нейронной сети состоит из $n$
нейронов с линейными функциями активации, где $i$-ый нейрон
соответствует $i$-ому узлу в сети. К выходам узлов, не являющихся соседями
текущего, отдельно прибавляется $-\infty$ (на практике --- большое отрицательное
число, например -1000000). Таким образом, на выходе нейросети образуются оценки
функции $Q(s, a)$ для всех действий $a$, где для действий, недоступных в текущем
состоянии (узлов, не являющихся соседями), $Q(s, a) = -\infty$.

Применив к полученным значениям $Q(s, a)$ функцию softmax, агент получает
стохастическую стратегию $\pi(s)$, которая порождает действие ---
перенаправление текущего пакета в одного из соседей. Использование
softmax-стратегии помогает лучше соблюдать баланс между exploration и
exploitation.

Для адаптации к изменениям топологии сети алгоритм поддерживает модель сетевого
графа, используя протокол link-state, описанный в разделе
\ref{overview:link-state}. Этот граф считается частью текущего состояния агента
и подается на вход нейросети в виде матрицы смежности графа (рис.
\ref{nn-pic-2}). Это делается в целях более хорошей адаптации алгоритма к
обрывам и восстановлениям соединений в сети по сравнению с Q-routing.

В бакалаврской работе и \cite{mukhutdinov2019multi} показано, что случайно
проинициализированные нейросетевые агенты с данной архитектурой при работе
онлайн не способны сойтись к оптимальной стратегии даже спустя долгое время,
вследствие фундаментальной нестационарности мультиагентной системы. Для борьбы с
этим предлагается использовать предварительное обучение с учителем, взяв за
опорные значения функции $Q_s(d, x)$ длину кратчайшего пути между $s$ и $d$,
проходящего через $x$.

Также было показано, что применение experience replay ухудшает
производительность предобученной модели в условиях изменяющегося трафика в сети.

\subsection{Недостатки DQN-routing}

Наиболе существенным недостатком DQN-routing является то, что размер нейросети
зависит от размера графа, в котором соответствующий агент работает как
маршрутизатор. Причем, если размер выходного слоя нейросети зависит от размера
графа линейно, то размер входного слоя зависит от него же квадратично, за счет
получения на вход графа в виде матрицы смежности.

Это накладывает существенные ограничения на применимость алгоритма сразу в
нескольких смыслах:

\begin{itemize}
\item Квадратичный рост входного слоя с ростом количества вершин в графе сильно
  ограничивает масштабируемость алгоритма, делая целесообразным его применение
  только в небольших графах до 100 вершин;
\item Предобученная модель с заданной архитектурой может работать только в
  графах с количеством вершин $n$, где $n$ --- размер выходного слоя модели;
\item Более того, необходимость предварительного обучения с учителем исключает
  свободный перенос модели на произвольный граф с $n$ вершин; возможна адаптация
  только к топологиям, не слишком сильно отличающихся от встреченных во время
  предварительного обучения. Фактически, модель неустойчива даже к
  перенумерованию вершин.
\end{itemize}

Почти все эти недостатки являются прямым следствием использования унитарного
кода при подаче номеров вершин на вход нейросети.

В следующей секции будет рассмотрена модификация алгоритма DQN-routing, которая
избавлена от перечисленных недостатков.

\subsection{DQN-LE-routing}

Как было указано в предыдущей секции, корнем большинства проблем с алгоритмом
DQN-routing является использование унитарного кода для кодирования подаваемых на
вход нейросети вершин в графе. Номера вершин нельзя подавать на вход в чистом
виде, так как это неупорядоченные категориальные данные --- близость номеров 9 и
10 не имеет ничего общего с близостью вершин 9 и 10 в случайном графе, но
нейронная сеть устроена так, что близость значений на выходном слое коррелирует
с близостью значений на входном.

Унитарный код является универсальным методом для кодирования любых
категориальных данных, предотвращающим любые нежелательные корреляции. Однако,
не все корреляции являются нежелательными --- в случае вершин в графе, более близкие
по реберному расстоянию вершины имеет смысл кодировать более близкими
значениями.

Методы отображения вершин графа в векторные пространства с более низкими
размерностями называются \textit{графовыми эмбеддингами} (\textit{англ.} graph
embeddings). Существует множество алгоритмов для получения эмбеддингов из вершин
графа \cite{cai2018comprehensive, goyal2018graph}, различающихся по свойствам и
вычислительной сложности. 

Графовые эмбеддинги можно строить, основываясь на различных метриках похожести
вершин. Для целей усовершенствования алгоритма DQN-routing нам подойдут эмбеддинги,
сохраняющие информацию о локальной схожести вершин -- т. е. чем дальше друг от
друга находятся вершины, тем дальше друг от друга должны находиться вектора -- и
наоборот.

В целях получения эмбеддингов для подачи на вход нейросети в модифицированном
алгоритме DQN-routing был использован метод Laplacian Eigenmaps. Его
преимущества:

TBD
\begin{figure}[!h]
  \caption{DQN-LE-routing: архитектура сети}\label{nn-1-one-out}
  \centering
  \includegraphics[scale=1]{nn-1-one-out}
\end{figure}

TBD

\section{Модификация вознаграждений для оптимизации энергопотребления}

\chapterconclusion

TBD

\chapter{Эксперименты}\label{experiments}

Экспериментальное сравнение разработанных алгоритмов проводилось в двух
имитационных моделях: модели абстрактной компьютерной сети и модели конвейерной
системы. Эксперименты в модели абстрактной компьютерной сети использовались для
того, чтобы проверять работоспособность базовой структуры рассматриваемого
алгоритма в относительно простом сеттинге. Кроме того, симуляция компьютерной
сети является менее вычислительно интенсивной задачей, чем симуляция конвейерной
системы. Также, существуют хорошо изученные способы генерации случайных графов,
обладающих топологическими свойствами, аналогичными таковым у реальных
компьютерных сетей (например, модель Барабаши-Альберт
\cite{albert2002statistical}), в то время как случайная генерация правдоподобных
моделей конвейерной сети является нетривиальной нерешенной задачей. Все это
делает модель компьютерной сети хорошей площадкой для первичного анализа
разработанного алгоритма.

Стоит, однако, подчеркнуть, что рассматривается модель \textit{абстрактной}
компьютерной сети. Отличие рассматриваемой модели от модели реальной
компьютерной сети заключается в том, что служебные сообщения передаются между
узлами мгновенно, в отличие от целевых пакетов, которые испытывают задержку при
проходе по соединениям и в очередях обработки на узлах. Это сделано для того,
чтобы приблизить модель абстрактной компьютерной сети к модели реальной
конвейерной сети.

Каждый тестовый сценарий для каждого типа алгоритма был запущен трижды с
различными числами инициализации генератора случайных чисел (были использованы
числа 42, 43 и 44). Целевые значения усреднялись на временных отрезках в 500
единиц времени модели. На представленных графиках линиями представлены значения,
усредненные по трем запускам сценария; соответствующими линиям полупрозрачными
полосами изображены разбросы между минимальным и максимальным значениями по трём
запускам.

\section{Эксперименты в модели абстрактной компьютерной сети}\label{experiments:network}

При проведении экспериментов в модели абстрактной компьютерной сети разработанные алгоритмы
сравнивались со следующими бейзлайнами:

\begin{itemize}
  \item \textbf{Shortest paths (SP)}: aлгоритм кратчайших путей, использующий
    протокол link-state; выбран, так как link-state алгоритмы являются наиболее
    распространенными алгоритмами маршрутизации
  \item \textbf{Q-routing}, описанный в разделе \ref{q-routing-desc} и
    являющийся идейным предком предложенных алгоритмов DQN-routing и DQN-LE-routing.
  \item TBD: добавить бейзлайны
\end{itemize}

Нейросетевые агенты для алгоритмов DQN-routing и DQN-LE-routing перед работой
проходили предварительное обучение с учителем на эпизодах работы алгоритма
кратчайших путей внутри графа из 10 вершин (Рис.~\ref{fig-simple-network}).
Каждое соединение в графе имеет задержку 10 мс и пропускную способность 1024 байт/мс.
Каждый пакет имеет размер 1024 байт, каждый роутер обрабатывает один пакет за 5
мс. Алгоритм кратчайших путей в качестве веса ребра использует его задержку.

Всего было сгенерировано 230000 эпизодов, включая эпизоды работы на версиях
данного графа с некоторыми отсутствующими ребрами. Для DQN-LE агента
использовались графовые эмбеддинги размерности 8. Оба нейросетевых агента
обучались на данных в течение 10 эпох с помощью алгоритма RMSProp \cite{tieleman2012lecture}.

\begin{figure}[!h]
  \caption{Базовый граф для тестов в модели компьютерной сети}\label{fig-simple-network}
  \centering
  \includegraphics[scale=0.6]{graph-2.pdf}
\end{figure}

\subsection{Адаптация к изменениям интенсивности трафика}

\begin{figure}[!h]
  \caption{Резкое понижение и последующее снижение нагрузки}\label{experiments:network:peak-load-small}
  \centering
  \includegraphics[width=\textwidth]{peak-load-small}
\end{figure}

В этом сценарии пакеты перемещаются между двумя половинами
графа \ref{fig-simple-network} (между множествами вершин $\{1, 2, 3, 7\}$ и
$\{4, 5, 6, 8\}$). Сначала пакеты посылаются раз в 10 мс, затем нагрузка резко
возрастает --- пакеты посылаются с периодом 3.5 мс ---, и в конце падает вновь.

В условиях повышения нагрузки на сеть и перегрузки <<популярных>> роутеров,
через которые проходит большинство кратчайших путей (узлы 7 и 8 в графе
\ref{fig-simple-network}) алгоритм shortest paths не способен работать эффективно,
как видно на графике \ref{experiments:network:peak-load-small} --- очереди этих
роутеров начинают стремительно расти, а с ними и среднее время доставки пакетов.
Все прочие алгоритмы оказываются способны быстро обнаружить затор и повести
трафик обходным путём.

\subsection{Изменение топологии сети}\label{experiments:simple/links}

\begin{figure}[!h]
  \caption{Обрыв и последующее восстановление трех соединений}\label{experiments:network:topology-change-small}
  \centering
  \includegraphics[width=\textwidth]{topology-change-small}
\end{figure}

В этом сценарии при небольшой нагрузке в сети производился последовательный
обрыв соединений $(7, 8)$, $(1, 2)$ и $(5, 6)$ и последующее их восстановление в том
же порядке. Пакеты посылались, как и в предыдущем сценарии, между двумя
половинами графа \ref{fig-simple-network}.

Как видно на графике \ref{experiments:network:topology-change-small}, алгоритмы
DQN- и DQN-LE-routing в этом сценарии работают почти в точности так же, как и
оптимальный в этой ситуации алгоритм кратчайших путей, в то время как Q-routing
не способен вернуться к оптимальному поведению после восстановления всех
соединений.

\subsection{Перенос опыта на новые топологии графов}

Необходимость предобучения для работы в графе заданной топологии является
существенным недостатком алгоритма DQN-routing, сильно ограничивающим его
практическую ценность. Алгоритм DQN-LE-routing тоже требует предобучения, но
благодаря использованию графовых эмбеддингов обобщающая способность единожды
обученной модели гораздо выше.

\begin{figure}[!h]
  \caption{Случайный граф из 10 вершин}\label{fig-random-net-10n}
  \centering
  \includegraphics[scale=0.7]{random-graph-10n}
\end{figure}

Нейросетевые агенты для алгоритмов DQN- и DQN-LE-routing, обученные на данных с
базового графа из 10 вершин (рис. \ref{fig-simple-network}), были использованы
для работы в случайном графе из 10 вершин, сгенерированном по модели
Барабаши-Альберт с параметром $m = 2$ и случайными значениями задержки
соединений от 10 до 20 мс. Прочие параметры сгенерированного графа идентичны
таковым в базовом графе. 

\begin{figure}[!h]
  \caption{Перенос опыта на новую топологию графа}\label{experiments:network:transfer-small}
  \centering
  \includegraphics[width=\textwidth]{learning-transfer-small}
\end{figure}

График \ref{experiments:network:transfer-small} демонстрирует показатели работы
алгоритмов в новом графе при низкой нагрузке. Работа алгоритма кратчайших
путей (оптимального при низкой нагрузке) также приведена для сравнения. Видно,
что DQN-routing ведет себя в новом графе хаотично и даже не способен сойтись к
какой-либо стабильной стратегии. В отличие от него, DQN-LE-routing работает
оптимально (аналогично алгоритму кратчайших путей) с самого начала, что
позволяет сделать вывод, что опыт нейросети, полученый при обучении, очень
хорошо обобщается на графы того же размера.

\begin{figure}[!h]
  \caption{Случайный граф из 40 вершин}\label{fig-random-net-40n}
  \centering
  \includegraphics[scale=0.7]{random-graph-40n}
\end{figure}

\begin{figure*}[!h]
  \centering
  \subfloat[Низкая нагрузка]{
    \includegraphics[width=0.4\textwidth]{learning-transfer-big-low-load}
    \label{experiments:network:transfer-big-low}}
  \hfil
  \subfloat[Высокая нагрузка]{
    \includegraphics[width=0.4\textwidth]{learning-transfer-big-high-load}
    \label{experiments:network:transfer-big-high}}
  \caption{Перенос опыта на новую топологию большего размера}\label{experiments:network:transfer-big}
\end{figure*}

Нейросетевой агент алгоритма DQN-routing, обученный на графе с $N$ вершинами,
принципиально не может работать на графах большего размера, однако
DQN-LE-routing свободен от этого ограничения, так как векторные представления
заданной размерности $d$ можно получить для вершин любого графа. На графиках
\ref{experiments:network:transfer-big-low} и
\ref{experiments:network:transfer-big-high} изображена работа алгоритма
DQN-LE-routing, предобученного на базовом графе из 10 вершин, внутри случайного
графа из 40 вершин (рис. \ref{fig-random-net-40n}), в условиях низкой и высокой
нагрузки. В условиях низкой нагрузки DQN-LE-routing начинает показывать
приемлемое качество работы существенно быстрее, чем Q-routing, хоть и не
сходится к оптимальной стратегии аналогичной алгоритму кратчайших путей --- но к
ней не может сойтись и Q-routing. В условиях высокой нагрузки DQN-LE-routing
ведет себя существенно лучше обоих бейзлайнов --- shortest path переполняет
очереди ключевых узлов и расходится, Q-routing долгое время ведет себя хаотично,
прежде чем сойтись к очень неоптимальной стратегии, в то время как
DQN-LE-routing работает как часы.

Из результатов экспериментов можно сделать вывод, что предобученный DQN-LE-routing обладает
хорошей обобщающей способностью и способен успешно работать на большом множестве
различных графов.

\section{Эксперименты в модели конвейерной системы}\label{experiments:conveyors}

В отличие от модели компьютерной сети, в модели конвейерной системы алгоритм
будет пытаться оптимизировать не только среднее время доставки пакета
(чемодана), но и \textit{энергопотребление} конвейеров. Оптимизация
энергопотребления заключается в том, чтобы использовать для доставки чемоданов
до точек назначения как можно меньше конвейеров.

В алгоритме DQN-routing на вход нейросети будет дополнительно подаваться вектор
$w$ размера $n$ (где $n$ --- количество конвейерных секций в системе), в котором на $i$-ой
позиции стоит 0, если конвейер, на котором находится секция $i$, в данный момент
находится в состоянии ожидания, и 1 --- если он работает.

В алгоритме DQN-LE-routing при расчете Q-функции для соседней секции $x$ на вход
нейросети будет дополнительно подаваться число 1, если конвейер, на котором
находится секция $x$, работает, и 0 --- если не работает.

Эксперименты проводились на модели конвейерной сети из 14 конвейеров с 27
секциями в сумме, двумя входными вершинами и четырьмя выходными вершинами (рис.
\ref{test-conveyors}). Секции с первой по 20 имеют длину 10 метров, с 21 по 27 --- 2
метра. Энергопотребление каждого конвейера равно 1 кВт, максимальная
скорость --- 1 м/c.

\begin{figure}[!h]
  \caption{Модель конвейерной системы для тестов}\label{test-conveyors}
  \centering
  \includegraphics[width=0.7\textwidth]{conveyor-1-illustration-1}
\end{figure}

\subsection{Неравномерный поток до выходных вершин}

Как можно видеть на иллюстрации \ref{test-conveyors}, кратчайший путь от входов
до выходов W и X пролегает через конвейеры 1, 2, 7 и 6, а до выходов Y и Z --
через конвейеры 1, 2, 3 и 4. Однако до выходов Y и Z также можно попасть через
конвейер 6, не задействуя конвейеры 3 и 4. Если для нас важно оптимизировать
энергозатраты, то в условиях небольшого входящего потока чемоданов такая
стратегия является более предпочтительной.

\begin{figure*}[!h]
  \centering
  \subfloat[Время сумок в пути]{
    \includegraphics[width=0.4\textwidth]{conveyors1-time}
    \label{experiments:conveyors:1-time}}
  \hfil
  \subfloat[Энергопотребление системы]{
    \includegraphics[width=0.4\textwidth]{conveyors1-energy}
    \label{experiments:conveyors:1-energy}}
  \caption{Неравномерный поток до выходных вершин}\label{experiments:conveyors:1}
\end{figure*}

В данном сценарии поток чемоданов попеременно идет либо только в выходы W и X,
либо во все четыре выхода сразу. Параметр важности экономии энергопотребления
$\alpha$ равен 1.

На иллюстрации \ref{experiments:conveyors:1} видно, что алгоритмы DQN- и
DQN-LE-routing после непродолжительного периода адаптации начинает работать
заметно лучше алгоритмов shortest paths и Q-routing с точки зрения экономии энергии,
жертвуя средним временем доставки чемодана. 

\subsection{Плавное повышение нагрузки}

\begin{figure*}[!h]
  \centering
  \subfloat[Время сумок в пути]{
    \includegraphics[width=0.4\textwidth]{conveyors2-late-time}
    \label{experiments:conveyors:2-late-time}}
  \hfil
  \subfloat[Энергопотребление системы]{
    \includegraphics[width=0.4\textwidth]{conveyors2-late-energy}
    \label{experiments:conveyors:2-late-energy}}
  \caption{Плавное повышение нагрузки: $\alpha = 1$, $\alpha_{LE} = 0.4$}\label{experiments:conveyors:2-late}
\end{figure*}

Первая половина этого сценария повторяет предыдущий --- поток попеременно идет то
во все выходы, то только в выходы W и X. Во второй половине сценария частота
появления чемоданов на входах возрастает в два раза и продолжает плавно расти.

В этом сценарии алгоритмы DQN- и DQN-LE-routing используют разные параметры
важности экономии энергопотребления, обоначенные соотв. $\alpha$ и
$\alpha_{LE}$, так как на практике алгоритм DQN-LE-routing оказался более
чувствительным к величине этого параметра.

\begin{figure*}[!h]
  \centering
  \subfloat[Время сумок в пути]{
    \includegraphics[width=0.4\textwidth]{conveyors2-early-time}
    \label{experiments:conveyors:2-early-time}}
  \hfil
  \subfloat[Энергопотребление системы]{
    \includegraphics[width=0.4\textwidth]{conveyors2-early-energy}
    \label{experiments:conveyors:2-early-energy}}
  \caption{Плавное повышение нагрузки: $\alpha = 0.8$, $\alpha_{LE} = 0.2$}\label{experiments:conveyors:2-early}
\end{figure*}

Графики \label{experiments:conveyors:2-late}
и \label{experiments:conveyors:2-early} показывают, что при постепенном
увеличении интенсивности трафика (и, как следствие, загруженности конвейеров)
алгоритмы DQN- и DQN-routing в какой-то момент начинают использовать конвейеры 3
и 4, чтобы снизить среднюю скорость доставки чемоданов, причем это происходит
тем раньше, чем ниже параметр $\alpha$ ($\alpha_{LE}$).

\chapterconclusion

TBD

%% Макрос для заключения. Совместим со старым стилевиком.
\startconclusionpage

TBD

%% Обратите внимание на heading. Без него тоже работает, но название будет другим.
\printmainbibliography

%% После этой команды chapter будет генерировать приложения, нумерованные русскими буквами.
%% \startappendices из старого стилевика будет делать то же самое
\appendix

%% \chapter{Промежуточные результаты исследования}\label{apx:bad-results}

%% TBD

\chapter{Описание разработанных имитационных моделей}\label{apx:simulators}

\begin{figure}[!h]
  \caption{Пример представления конфигурации конвейерной системы в виде
    направленного графа}\label{conveyor-graph-representation}
  \centering
  \includegraphics[width=\textwidth]{conveyor-1-illustration-2}
\end{figure}

Наиболее приближенная к реальности модель энергопотребления конвейера из
известных автору \cite{zhang2011modeling}, к сожалению, предназначена для расчета энергопотребления
конвейера для насыпных грузов.
Согласно , 

\end{document}
